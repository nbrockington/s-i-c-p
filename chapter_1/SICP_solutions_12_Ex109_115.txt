SCIP_solutions_12_Ex109_115.txt

My solutions to the SICP Exercises 1.9 to 1.15, from Section 1.2. 

******
200403
200404

(Exercise 1.9) 

Each of the following two procedures defines a method for adding two
positive integers in terms of the procedures inc, which increments its
argument by 1, and dec, which decrements its argument by 1.

Using the substitution model, illustrate the process generated by each
procedure in evaluating (+ 4 5). Are these processes iterative or
recursive?


Procedure 1: 

(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))


This process is linear recursive by the subsitution model:

(+ 4 5)
(1+ (+ 3 5))
(1+ (1+ (+ 2 5)))
(1+ (1+ (1+ (+ 1 5))))
(1+ (1+ (1+ (1+ (+ 0 5)))))
(1+ (1+ (1+ (1+ 5))))
(1+ (1+ (1+ 6)))
(1+ (1+ 7))
(1+ 8)
9


Procedure 2: 

(define (+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))


The process is linear interative by the substitution model:

(+ 4 5)
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9


(Exercise 1.10) 

The following procedure computes a mathematical function called
Ackermann's function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

What are the values of the following expressions?

(A 1 10) -> 1024 (= 2^10)
(A 0 (A 1 9))
(A 0 (A 0 (A 1 8)))
(A 0 (A 0 (A 0 (A 1 7))))
(A 0 (A 0 (A 0 (A 0 (A 1 6)))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 1 5))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 4)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 3))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 1 1))))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 2)))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 4))))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 (A 0 8)))))))
(A 0 (A 0 (A 0 (A 0 (A 0 (A 0 16))))))
(A 0 (A 0 (A 0 (A 0 (A 0 32)))))
(A 0 (A 0 (A 0 (A 0 64))))
(A 0 (A 0 (A 0 128)))
(A 0 (A 0 256))
(A 0 512)
1024


(A 2 4) -> 65536 (= 2^2^2^2 = 2^^4)
(A 1 (A 2 3))
(A 1 (A 1 (A 2 2)))
(A 1 (A 1 (A 1 (A 2 1))))
(A 1 (A 1 (A 1 2)))
(A 1 (A 1 4))   [* from above]
(A 1 16 )       [* from above]
65536           [* from formula deduced, see below]


(A 3 3) -> 65536
(A 2 (A 3 2))
(A 2 (A 2 (A 3 1)))
(A 2 (A 2 2))
(A 2 4)  [* from above]
65536    [* from above]


Consider the following procedures, where A is the procedure defined above:

(define (f n) (A 0 n))

(define (g n) (A 1 n))

(define (h n) (A 2 n))

(define (k n) (* 5 n n))

Give concise mathematical definitions for the functions computed by
the procedures f, g, and h for positive integer values of n. For
example, (k n) computes 5n^2.

(f n) -> computes 2n, because if (= x 0), (* 2 y)

(g n) -> computes 2^n, because we multiply (A 0 _) = (* 2 _)
recursively, y-many times

(h n) -> computes 2^^n, that is, iteratred exponentiation (tetration),
because we must do 2^(A 1 _) y-many times, recursively.



(Exercise 1.11)

; A function f is defined by the rule that f(n) = n if n < 3 and f(n)
; = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n q> 3. Write a procedure that
; computes f by means of a recursive process. Write a procedure that
; computes f by means of an iterative process.


; Recursive f

(define (frec n)
   (cond ((< n 3) n)
         (else (+ (frec (- n 1)) (* 2 (frec (- n 2))) (* 3 (frec (- n 3)))))))


; Iterative f

(define (fiter n)
   (if (< n 3)
       n
       (iter 2 1 0 n)))


(define (iter a b c count)
   (if (< count  3)
       a
       (iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))



(Exercise 1.12)

;   The following pattern of numbers is called Pascal's triangle. The
;   numbers at the edge of the triangle are all 1, and each number
;   inside the triangle is the sum of the two numbers above it. Write
;   a procedure that computes elements of Pascal's triangle by means
;   of a recursive process.

; NB. In this procedure, inputs n and r are taken to refer to the
; binomial coefficeint "nCr" where 0 ≤ r ≤ n.


(define (pascal n r)
   (cond ((= r 0) 1)
         ((= r n) 1)
         (else (+ (pascal (- n 1) (- r 1)) (pascal (- n 1) r)))))






(Exercise 1.13)

Prove that Fib(n) is the closest integer to (phi^n)/sqrt(5), where phi
= (1 + sqrt(5))/2. Hint: Let psi = (1 - sqrt(5))/2. Use induction and
the definition of the Fibonacci numbers (see section 1.2.2) to prove
that Fib(n) = (phi^n - psi^n)/sqrt(5).

[* NB. In what follows, I have substituted variable x for letter phi
and variable y for letter psi in the question.]

Proof that Fib(n) is the closest integer to x^n/sqrt(5):

Note that by application of the quadratic formula, both x = (1 +
sqrt(5))/2 and y = (1 - sqrt(5))/2 satisfy equation z^2 = z + 1.

Lemma: Fib(n) = (x^n - y^n)/sqrt(5) :

Proof by induction of Lemma:
      
Basis case n = 0: (x^0 - y^0)/sqrt(5) = 0 CORRECT

Basis case n = 1: (x^1 - y^1)/sqrt(5)

= ((1 + sqrt(5)) - (1 - sqrt(5)))/ (2 * sqrt(5))

= (2 * sqrt(5)) / (2 * sqrt(5))

= 1 CORRECT


Inductive step:

By definition of Fib, for n > 1, Fib(n) = Fib(n-1) + Fib(n-2).

Assume induction hypothesis i.e. formula Fib(k) = (x^k - y^k)/sqrt(5)
holds for 0 ≤ k ≤ (n-1).

We need to show that it holds for k = n. 

By indictive hypothesis, Fib(n-1) + Fib(n-2) = 

= ( (x^(n-1) - y^(n-1))/sqrt(5) ) + ( (x^(n-2) - y^(n-2))/sqrt(5) )

= ( x^(n-1) + x^(n-2) - y^(n-1) - y^(n-2) ) /sqrt(5)

= ( (x + 1)(x^(n-2)) - (y+1)(y^(n-2)) ) /sqrt(5)

= ( (x^2)(x^(n-2)) - (y^2)(y^(n-2)) ) / sqrt(5)

= ( x^n - y^n ) / sqrt(5).

Hence Fib(k) = (x^k - y^k)/sqrt(5) for all natural numbers k. []

Since 0 < abs(y) = abs((1 - sqrt(5))/2) ≈ abs(-0.6180...) < 1, for
large values of n, y^n/sqrt(5) tends to zero. In particular,
y^n/sqrt(5) < 0.5 for all values of natural numbers n.

Hence, for all n, (x^n - y^n)/sqrt(5) is within 0.5 of x^n/sqrt(5), so
Fib(n) ≈ x^n/sqrt(5), to 0 decimal places (i.e., closest integer). []



(Exercise 1.4) 

The recursion tree diagram helps us to answer this question. 

The tree depth indicates how many statements need to be executed until
the base case is reached. This corresponds to the memory/space
complexity, because each function call will be stored on the program
stack. For our count-change procedure, each succesive node of the tree
has n reduced by 1, so the tree will have a depth of n before it
reaches the base case. Hence growth of space is O(n). (NB. There is
some overhead that is constant in the number of coins--5-- which can
be ignored).

The tree breadth indicates how many total recursive function calls
will be made. This corresponds to the time complexity of the program,
because each call requires steps to be taken. For our count-change
procedure, for large values of n, in general each node splits into 2
branches there is a total of n levels. Hence the total number of nodes
is approximately 2^n, so time complexity is O(2^n). (NB. For smaller
values of n i.e. less than 50 centres, some nodes die quickly because
(a - d) < 0, but this can be ignored).




(Exercise 1.5)

The sine of an angle (specified in radians) can be computed by making
use of the approximation sin x x if x is sufficiently small, and the
trigonometric identity sin(x) = 3sin(x/3) - 4sin^3(x/3) to reduce the
size of the argument of sin. (For purposes of this exercise an angle
is considered ``sufficiently small'' if its magnitude is not greater
than 0.1 radians.) These ideas are incorporated in the following
procedures:

(define (cube x) (* x x x))

(define (p x) (- (* 3 x) (* 4 (cube x))))

(define (sine angle)
   (if (not (> (abs angle) 0.1))
       angle
       (p (sine (/ angle 3.0)))))

a.  How many times is the procedure p applied when (sine 12.15) is evaluated?

(sine 12.15)
(p (sine 4.05))
(p (p (sine 1.35)))
(p (p (p (sine 0.45))))
(p (p (p (p (sine 0.15)))))
(p (p (p (p (p (sine 0.05))))))
(p (p (p (p (p (0.05))))))

The procedure p is applied five times when (sine 12.15) is evaluated. 

b. What is the order of growth in space and number of steps (as a
function of a) used by the process generated by the sine procedure
when (sine a) is evaluated?

ANS:

This is a linear recursive process where the value of a is divided by
3 each time until it reaches the base case of 0.1 (or less).

Order of growth in space: O(log (a)) (base 3), because p is applied to
a recursively until the basis case is reached, and the value of a is
divided by 3 each time.

Order of growth in number of steps: as for growth in time, since the
number of steps is approximately twice the number of application of p
(because this process is a linear recursion).






	 
